# os_plus_threads.gtu
# OS ve Iki Basit Iplik (Thread 1 & Thread 2)
# Adres cakismalari ve scheduler mantigi duzeltilmis hali
# Corrections: Line 654 (SET 1, 15), Line 655 (SYSCALL_PRN 15), Line 706 (JIF 0, 203)

#-----------------------------------------------------
# VERI BOLUMU
#-----------------------------------------------------
Begin Data Section
    # --- CPU Ozel Yazmaclari ---
    0 = 200         # OS PC Baslangici
    1 = 990         # OS SP Baslangici
    # memory[2] (SysCall Result) CPU tarafindan YIELD sonrasi donus PC'sini tutacak
    # memory[3] (Instr Executed) CPU tarafindan kullanilir

    # --- OS Ozel Alanlari ---
    10 = 0          # Son Syscall Turu (0:PRN, 1:HLT, 2:YIELD) - CPU ayarlar
    11 = 300        # SYSCALL_HLT Handler Adresi
    12 = 400        # SYSCALL_YIELD Handler Adresi
    13 = 500        # SYSCALL_PRN Handler Adresi
    15 = 0          # current_running_thread_id (0:OS, 1:T1, 2:T2) - OS gunceller
    16 = 1          # next_thread_to_run_id (Scheduler bunu gunceller)
    17 = 0          # Gecici - YIELD yapan ipligin TCB'sine kaydedilecek PC'yi tutar
    18 = 0          # Gecici - YIELD yapan ipligin TCB'sine kaydedilecek SP'yi tutar
    19 = 0          # Temporary storage for PRN address argument
    
    # --- TCB (Thread Kontrol Bloğu) Yapıları ---
    # Her TCB için 7 bellek hücresi:
    # Offset 0: ID
    # Offset 1: State (0:Ready, 1:Running, 2:Blocked, 3:Halted)
    # Offset 2: SavedPC
    # Offset 3: SavedSP
    # Offset 4: UnblockIECount (PRN blokajı için hedef IE)
    # Offset 5: StartingIE (Thread ilk çalıştığında memory[3] değeri)
    # Offset 6: UsedIE (Thread'in kendi kullandığı IE - başlangıçta 0)
    # TCB_SIZE = 7

# OS (Thread 0) - ID=0
    20 = 0          # TCB0_ID
    21 = 1          # TCB0_STATE (Running)
    22 = 200        # TCB0_PC
    23 = 990        # TCB0_SP
    24 = 0          # TCB0_UnblockIECount (OS için kullanılmaz)
    25 = 0          # TCB0_StartingIE (OS için anlamsız olabilir, başlangıç IE'si 0 veya ilk komut sonrası)
    26 = 0          # TCB0_UsedIE (OS için takip edilebilir veya 0 bırakılabilir)


    # TCB1 (Thread 1 - ID=1)
    30 = 1          # TCB1_ID
    31 = 0          # TCB1_STATE (Başlangıçta Ready)
    32 = 1000       # TCB1_SavedPC_START (Başlangıç PC'si)
    33 = 1990       # TCB1_SavedSP_START (Başlangıç SP'si)
    34 = 0          # TCB1_UnblockIECount (Başlangıçta 0)
    35 = 0          # TCB1_StartingIE (Başlangıçta 0, ilk çalıştığında güncellenecek)
    36 = 0          # TCB1_UsedIE (Başlangıçta 0)

    # TCB2 (Thread 2 - ID=2)
    40 = 2          # TCB2_ID
    41 = 0          # TCB2_STATE (Başlangıçta Ready)
    42 = 2000       # TCB2_SavedPC_START (Başlangıç PC'si)
    43 = 2990       # TCB2_SavedSP_START (Başlangıç SP'si)
    44 = 0          # TCB2_UnblockIECount (Başlangıçta 0)
    45 = 0          # TCB2_StartingIE (Başlangıçta 0, ilk çalıştığında güncellenecek)
    46 = 0          # TCB2_UsedIE (Başlangıçta 0)

    # --- Gecici Hesaplama/Saklama Alanlari (OS Kullanimi Icin) ---
    70 = 0          # USER komutu icin yeni PC'yi (iplik PC'si) tutar
    71 = 0          # Karsilastirma / TCB adresi icin gecici deger
    72 = 0          # Karsilastirma / iplik ID'si / state icin gecici deger
    73 = 1          # Sabit 1
    74 = 2          # Sabit 2
    75 = 3          # Sabit 3 (Halted state)
    76 = 4          # TCB_SIZE (ID, State, PC, SP)
    77 = 20         # TCB_START_ADDRESS (ilk TCB'nin baslangic adresi - OS TCB'si)
    # TCB Offsetleri: ID_OFFSET=0, STATE_OFFSET=1, PC_OFFSET=2, SP_OFFSET=3

    78 = 0          # CHECK_THREADS icin t1_state gecici alani
    79 = 0          # CHECK_THREADS icin t2_state gecici alani
    80 = 0          # TCB1_STATE_ADDR (Hesaplanacak: 20 + 1*4 + 1 = 25)
    81 = 0          # TCB1_PC_ADDR (Hesaplanacak: 20 + 1*4 + 2 = 26)
    82 = 0          # TCB1_SP_ADDR (Hesaplanacak: 20 + 1*4 + 3 = 27)
    83 = 0          # TCB2_STATE_ADDR (Hesaplanacak: 20 + 2*4 + 1 = 29)
    84 = 0          # TCB2_PC_ADDR (Hesaplanacak: 20 + 2*4 + 2 = 30)
    85 = 0          # TCB2_SP_ADDR (Hesaplanacak: 20 + 2*4 + 3 = 31)

    
    # --- THREAD 1 Veri Alani (1000-1999) ---
    1050 = 111      # Thread 1'in yazdiracagi ilk deger
    1051 = 112      # Thread 1'in yazdiracagi ikinci deger
    1052 = 2

    1200 = 0
    1201 = 0

    # --- THREAD 2 Veri Alani (2000-2999) ---
    2050 = 221
    2051 = 222
    2052 = 3

    2200 = 0
    2201 = 0

End Data Section

Begin Instruction Section
    #-----------------------------------------------------
    # ISLETIM SISTEMI KOMUTLARI (Baslangic PC=200)
    #-----------------------------------------------------
    # --- OS Baslangic ---
200: SET 0, 15      # current_running_thread_id = 0 (OS)
201: SET 1, 16      # next_thread_to_run_id = 1
202: CALL 600       # GOTO_SCHEDULER_AND_RUN_THREAD
203: HLT            # OS Final HLT






# --- Sistem Cagrisi Isleyicileri ---
    # SYSCALL_HLT Handler (memory[11]=300)
    # HLT yapan ipligin ID'si SYSCALL aninda memory[15]'te (current_running_thread_id) idi.
300: CPY 15, 72     # halted_thread_id = memory[15] (SYSCALL yapan ipligin ID'si)
301: SET 0, 15      # current_running_thread_id = 0 (OS kontrolu aldi)

    # Halted thread'in STATE'ini 'Halted' (3) yap.
    # temp_id (memory[70]) = halted_thread_id - 1 hesapla
302: CPY 72, 70     # temp_id (memory[70]) = halted_thread_id (memory[72])
303: ADD 70, -1     # temp_id (memory[70]) = temp_id - 1

    # if (temp_id <= 0) yani (halted_thread_id == 1) ise 310'a git
304: JIF 70, 310

    # ELSE (halted_thread_id == 2)
305: SET 3, 41      # TCB2_STATE (memory[41]) = Halted (3)
306: JIF 15, 311     # Her zaman Scheduler'a git (312)

    # IF (halted_thread_id == 1)
310: SET 3, 31      # TCB1_STATE (memory[31]) = Halted (3)
    # Her iki durumda da Scheduler'i cagir
311: CALL 600       # Bir sonraki ipligi calistir veya OS'yi HLT et (scheduler karar verir)
312: HLT          # Guvenlik HLT'si





# SYSCALL_YIELD Handler (memory[12]=400)
400: CPY 15, 72     # yielded_thread_id = memory[15]
401: SET 0, 15      # current_running_thread_id = 0 (OS kontrolu aldi)
402: CPY 2, 17      # saved_pc = memory[2] 
403: CPY 1, 18      # saved_sp = memory[1]

404: JIF 15, 407   

# Thread kontrolu
407: CPY 72, 70     # temp_id = yielded_thread_id
408: ADD 70, -1     # temp_id = temp_id - 1 
409: JIF 15, 410 
410: JIF 70, 425    # IF temp_id <= 0 (yani yielded_id == 1 or 0 or less) GOTO TCB1_Save_Context

    # ELSE (yielded_id > 0, presumably 2 if not 1) - Thread 2'nin context'ini kaydet
411: CPY 17, 42     # TCB2_PC = saved_pc
412: CPY 18, 43     # TCB2_SP = saved_sp
413: SET 0, 41      # TCB2_STATE = Ready (0)
414: SET 1, 16      # next_thread_to_run_id = 1
415: JIF 15, 430     # GOTO Scheduler

    # TCB1_Save_Context (yielded_id was 1, or erroneously 0 or less)
425: CPY 17, 32     # TCB1_PC = saved_pc
426: CPY 18, 33     # TCB1_SP = saved_sp
427: SET 0, 31      # TCB1_STATE = Ready (0)
428: SET 2, 16      # next_thread_to_run_id = 2
429: JIF 0, 430     # GOTO Scheduler

    # Scheduler'i cagir
430: CALL 600       # GOTO_SCHEDULER_AND_RUN_THREAD
431: HLT            # Guvenlik HLT'si




#-----------------------------------------------------
# SYSCALL_PRN_HANDLER (Baslangic Adresi: 500, memory[13]'te belirtildi)
#-----------------------------------------------------
# CPU bu handlera geldiginde:
# - KERNEL modundadir.
# - memory[15]'te PRN cagrisini yapan thread'in ID'si vardir.
# - memory[2]'de PRN cagrisini yapan thread'in donus adresi (PC_PRN + 1) vardir.
# Bu handler: Cagiran thread'i BLOCKED yapar, TCB'sini gunceller ve Scheduler'i cagirir.

500: CPY 15, 72     # prn_caller_thread_id_copy = memory[15] (cagiran thread'in ID'si)
501: CPY 2, 17      # saved_pc_for_tcb = memory[2] (donus PC'si)
502: CPY 1, 18      # saved_sp_for_tcb = memory[1] (o anki SP)
503: SET 0, 15      # current_running_thread_id = 0 (OS kontrolu aldi)

    # TCB'ye kaydedilecek "unblock_instruction_count" hesapla
    # unblock_IE = memory[3] (current_total_IE) + 100
504: CPY 3, 73      # temp_unblock_ie = memory[3] (o anki toplam IE)
505: ADD 73, 100    # temp_unblock_ie simdi (current_total_IE + 100) degerini tutuyor.

    # Hangi thread PRN yapti? ID'sine (memory[72]'de) gore TCB'yi guncelle.
506: CPY 72, 70     # temp_id_check = prn_caller_thread_id_copy
507: ADD 70, -1     # temp_id_check = temp_id_check - 1 (T1 icin 0, T2 icin 1 olacak)

508: JIF 70, 520    # Eger temp_id_check <= 0 (yani PRN yapan Thread 1 ise), 520'ye (TCB1_Block_Update) atla.
                     # Degilse (yani PRN yapan Thread 2 ise), asagi devam et.

    # --- Thread 2 PRN Yaptiysa Bu Blok Calisir (Adres 509'dan itibaren) ---
    # TCB2 Adresleri: State=memory[35], PC=memory[36], SP=memory[37], UnblockIE=memory[38]
    # Kaydedilecekler: PC (memory[17]'de), SP (memory[18]'de), UnblockIE (memory[73]'te)
    # Yeni State: BLOCKED (memory[74]'teki '2' degeri)
509: CPY 17, 42     # TCB2_SavedPC (memory[36]) = saved_pc_for_tcb (memory[17])
510: CPY 18, 43     # TCB2_SavedSP (memory[37]) = saved_sp_for_tcb (memory[18])
511: CPY 74, 41     # TCB2_STATE (memory[35]) = BLOCKED_STATE_CODE (memory[74]=2)
512: CPY 73, 44     # TCB2_UnblockIECount (memory[38]) = temp_unblock_ie (memory[73])
513: JIF 15, 530    # Kosulsuz olarak Scheduler'a git (memory[15] su an 0 oldugu icin)

    # --- Thread 1 PRN Yaptiysa Bu Blok Calisir (Adres 520'den itibaren) ---
    # (508'deki JIF buraya atladi cunku temp_id_check degeri 0 idi)
    # TCB1 Adresleri: State=memory[28], PC=memory[29], SP=memory[30], UnblockIE=memory[31]
520: CPY 17, 32     # TCB1_SavedPC (memory[29]) = saved_pc_for_tcb (memory[17])
521: CPY 18, 33     # TCB1_SavedSP (memory[30]) = saved_sp_for_tcb (memory[18])
522: CPY 74, 31     # TCB1_STATE (memory[28]) = BLOCKED_STATE_CODE (memory[74]=2)
523: CPY 73, 34     # TCB1_UnblockIECount (memory[31]) = temp_unblock_ie (memory[73])
524: JIF 15, 530    # Kosulsuz olarak Scheduler'a git (memory[15] su an 0 oldugu icin)

    # --- Scheduler'i Cagir (Her iki PRN durumundan sonra ortak nokta) ---
530: CALL 600       # Scheduler'i cagir
531: HLT            # Guvenlik HLT'si (Scheduler'dan donus olmamali)





# THREAD BLOCK KONTROLÜ CHECK_IF_THREAD_CAN_BE_UNBLOCKED

# --- PRN ile Block olan threadleri kontrol et --- 

# Şimdi ilk kontrol: Halted mi?
570: CPY 31, 72        # tekrar state al
571: ADD 72, -2        # STATE - 2
572: JIF 72, 574       # eğer state == 3 → T2'ye geç #jif e girip   574 gitmiyorsa  halteddir
573: JIF 15, 580       #  EĞER HALTEDSE YANİ 3 SE 3-2= 1 1 SE 574 E GİTMEZ 573 DEVAM EDER 573 DE OTOMATİK 580 T2 GİDER   
                       # 15 DE OSDA OLDUGUMUZ İCİN 0 ZATEN 
574: CPY 3, 70        # current_IE → mem[70]
575: CPY 34, 71       # TCB1_StartingIE → mem[71]
576: SUBI 70, 71       # fark = current_IE - (unblock_IE)
577: JIF 71, 580      #  fark <= 0 ise → thread1 hala block
578: SET 0, 31     # TCB1_STATE = Ready
579: SET 0, 34     # unblock_IE bilgisini sıfırla (opsiyonel ama temiz olur)


# Şimdi ilk kontrol: Halted mi?
580: CPY 41, 72        # tekrar state al
581: ADD 72, -2
582: JIF 72, 584       # eğer state == 3 → T2'ye geç
583: RET               # jife girmiyorsa halteddir

#SUBI  SUBI 70, 71  70 DEN 71 CİKARİYO SONRA 71 E KOYUYO 
# --- T2 kontrolü ---
584: CPY 3, 70        # current_IE → mem[70]
585: CPY 44, 71       # TCB2_StartingIE → mem[71]
586: SUBI 70, 71      # fark = current_IE - (startingIE + 100) 
587: JIF 71, 590     #  fark <= 0 ise → thread2 hala block
588: SET 0, 41     # TCB2_STATE = Ready
589: SET 0, 44     # unblock_IE bilgisini sıfırla (opsiyonel ama temiz olur)
590: RET






# --- Alt Program: SCHEDULER_AND_RUN_THREAD (Adres 600) ---
# SCHEDULERDA THREAD HLT ETMİS Mİ ONA DA BAKILACAK
600: CALL 700       # CHECK_IF_ALL_THREADS_HALTED
601: CALL 570       # PRN blokaj kontrolü (thread ready olmalı mı) hersey memory bossadirekt geciyor bunu
602: CPY 16, 71     # run_id_candidate = memory[16] -> memory[71] (bos gecici alan)

    # if run_id_candidate == 1     
603: CPY 71, 72     # run_id_candidate -> memory[72]
604: ADD 72, -1     # memory[72] = run_id_candidate - 1
605: JIF 72, 610    # Eger (run_id_candidate - 1) <= 0 (yani ID=1) ise 640'a git (T1 kontrol/yukle)

    # ELSE (run_id_candidate == 2) -> Thread 2'yi kontrol et/yukle
606: CPY 41, 72     # TCB2_STATE (memory[41]) -> memory[72]
607: JIF 72, 615    # Eger TCB2_STATE <= 0 (READY) ise 615'e git (T2 Yukle)
    # T2 Ready degilse (Blocked veya Halted ise), T1'i dene (next_id=1 yap)
608: SET 1, 16      # next_thread_to_run_id = 1
609: JIF 15, 600     # Scheduler'i en bastan tekrar cagir


# --- T1 için STATE kontrolü ---
610: CPY 31, 72      # TCB1_STATE → memory[72]
611: JIF 72, 650     # Eğer Ready ise çalıştır
612: SET 2, 16       # değilse T2 dene
613: JIF 15, 606

    # Thread 2'yi Yukle ve Calistir (Adres 615)
615: CPY 43, 1       # CPU_SP = TCB2_SP
616: SET 2, 15       # current_running_thread_id = 2
617: SET 1, 41       # TCB2_STATE = Running     TCB2_StartingIE daha sonra tam hesaplanacak
618: CPY 3, 45       # TCB2_StartingIE (memory[45]) = current_total_IE (memory[3])
619: CPY 42, 70      # memory[70] = TCB2_PC
620: USER 70         # memory[70]'ten PC yükle
621: HLT             # Güvenlik HLT'si


    # Thread 1'i kontrol et/yukle (Adres 640)
640: CPY 31, 72     # TCB1_STATE (memory[31]) -> memory[72]
641: JIF 72, 650    # Eger TCB1_STATE <= 0 (READY) ise 650'ye git (T1 Yukle)
    # T1 Ready degilse, T2'yi dene (next_id=2 yap)
642: SET 2, 16      # next_thread_to_run_id = 2
643: JIF 15, 600    # Scheduler'i en bastan tekrar cagir

# Thread 1'i Yukle ve Calistir (Adres 650)

650: CPY 33, 1      # CPU_SP = TCB1_SP (memory[33] degeri -> memory[1]'e)
651: SET 1, 15      # current_running_thread_id = 1
652: SET 1, 31      # TCB1_STATE (memory[31]) = Running 
653: CPY 3, 35      # TCB1_StartingIE (memory[35]) = current_total_IE (memory[3])
654: CPY 32, 70     # memory[70] = TCB1_PC (memory[32] degeri); USER komutu icin hedef PC'yi hazirla.
655: SET 0, 21      # TCB0_STATE = 0 (Ready veya Idle gibi davranır)
656: USER 70        # Kullanici moduna gec ve PC = memory[70]'deki adresten basla
657: HLT            # Guvenlik HLT'si (buraya ulasilmamasi gerekir)



# --- Alt Program: CHECK_IF_ALL_THREADS_HALTED (Adres 700) ---
# 73 -> 1 74 -> 2 75 -> 3  

700: CPY 31, 78     # t1_state = TCB1_STATE
701: CPY 41, 79     # t2_state = TCB2_STATE

# Thread 1: State < 3 mı kontrol et
702: ADD 78, -2     # memory[78] = t1_state - 3
703: JIF 78, 710    # If t1_state < 3, RET (negatif ise atla)

# Thread 2: State < 3 mü kontrol et  
704: ADD 79, -2     # memory[79] = t2_state - 3
705: JIF 79, 710    # If t2_state < 3, RET (negatif ise atla)

# İkisi de State ≥ 3 (Halted)
706: JIF 0, 203     # İkisi de Halted, OS'yi HLT et

710: RET            # En az biri Ready/Running/Blocked (State < 3)



#-----------------------------------------------------
    # THREAD 1 KOMUTLARI (Baslangic: 1000) - Basitlestirilmis Hali
    #-----------------------------------------------------
1000: SET 111, 1050      # Ilk degeri ayarla
1001: SYSCALL_PRN 1050   # Ilk degeri yazdir (111 bekleniyor)
1002: SYSCALL_YIELD      # CPU'yu OS'e birak
1003: SET 112, 1051      # YIELD sonrasi ikinci degeri ayarla
1004: SYSCALL_PRN 1051   # Ikinci degeri yazdir (112 bekleniyor)
1005: SYSCALL_HLT        # Thread 1'i sonlandir

#-----------------------------------------------------
    # THREAD 2 KOMUTLARI (Baslangic: 2000) - Basitlestirilmis Hali
    #-----------------------------------------------------
2000: SET 221, 2050      # Ilk degeri ayarla
2001: SYSCALL_PRN 2050   # Ilk degeri yazdir (221 bekleniyor)
2002: SYSCALL_YIELD      # CPU'yu OS'e birak
2003: SET 222, 2051      # YIELD sonrasi ikinci degeri ayarla
2004: SYSCALL_PRN 2051   # Ikinci degeri yazdir (222 bekleniyor)
2005: SYSCALL_HLT        # Thread 2'yi sonlandir


End Instruction Section
