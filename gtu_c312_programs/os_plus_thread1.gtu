# os_plus_thread1.gtu
# OS ve Thread 1'i içeren birleşik dosya (DÜZELTİLMİŞ)

#-----------------------------------------------------
# İŞLETİM SİSTEMİ BÖLÜMÜ
#-----------------------------------------------------
Begin Data Section
    # --- CPU Özel Yazmaçları (OS bunları kendi başlangıç değerleriyle ayarlar) ---
    0 = 200         # OS Program Counter Başlangıcı (Komutlar 200'den başlasın)
    1 = 990         # OS Stack Pointer Başlangıcı (OS Yığını için 990-999 arası 10 hücre)
    # memory[2] (SysCall Result) CPU tarafından kullanılır
    # memory[3] (Instr Executed) CPU tarafından kullanılır

    # --- OS Tarafından Kullanılacak Özel Bellek Alanları ---
    10 = 0          # Son yapılan sistem çağrısının türü (CPU ayarlar: 0=PRN, 1=HLT, 2=YIELD)
    11 = 300        # SYSCALL_HLT Handler adresi (OS içinde, komut adresi 300)
    12 = 400        # SYSCALL_YIELD Handler adresi (OS içinde, komut adresi 400)
    15 = 0          # current_running_thread_id (0: OS, 1: Thread1, ...)

    # --- İplik Tablosu (Thread Control Block - TCB) ---
    # Her iplik için 6 hücre: BaseAddr=20
    # Offset: 0:ID, 1:State(0:Ready,1:Run,2:Block,3:Halt), 2:PC, 3:SP, 4:StackBase, 5:StackLimit
    # OS (Thread 0) - ID=0
    20 = 0          # TCB0_ID
    21 = 1          # TCB0_STATE (Running)
    22 = 200        # TCB0_PC
    23 = 990        # TCB0_SP
    24 = 999        # TCB0_STACK_BASE (En yüksek adres)
    25 = 900        # TCB0_STACK_LIMIT (En düşük adres, örnek)

    # Thread 1 - ID=1 (Programı 1000'de başlar, yığını 1990'dan aşağı, 1999 base)
    26 = 1          # TCB1_ID
    27 = 0          # TCB1_STATE (Ready)
    28 = 1000       # TCB1_PC (Thread 1'in ilk komut adresi)
    29 = 1990       # TCB1_SP (Thread 1'in başlangıç SP'si, yığın için 10 hücre: 1990-1999)
    30 = 1999       # TCB1_STACK_BASE (Yığının en yüksek adresi)
    31 = 1900       # TCB1_STACK_LIMIT (Yığının en düşük adresi)
    
    # Thread 2 için başlangıç (ID=2) - Programı 2000'de, Yığını 2990'dan aşağı, 2999 base
    32 = 2          # TCB2_ID
    33 = 3          # TCB2_STATE (Halted - SYSCALL HLT ilk komutu olacak varsayımı)
    34 = 2000       # TCB2_PC
    35 = 2990       # TCB2_SP
    36 = 2999       # TCB2_STACK_BASE
    37 = 2900       # TCB2_STACK_LIMIT

    # --- Geçici Değerler/Adresler için OS Alanı ---
    70 = 0          # USER komutu için Thread 1'in PC'sini tutacak geçici adres (OS kullanır)

    #-----------------------------------------------------
    # THREAD 1 VERİ BÖLÜMÜ
    #-----------------------------------------------------
    # Bu bölümdeki adresler Thread 1'in bellek alanı olan 1000-1999 arasında olmalı.
    1050 = 789      # SYSCALL_PRN ile yazdırılacak bir değer (Thread 1 verisi)
    1200 = 0        # Thread 1'in SET komutu için kullanacağı adres

End Data Section # TÜM VERİ BÖLÜMLERİ BİTTİ

Begin Instruction Section
    #-----------------------------------------------------
    # İŞLETİM SİSTEMİ KOMUTLARI
    #-----------------------------------------------------
    # --- OS Başlangıç ve Kurulum ---
200: SET 0, 15     # current_running_thread_id = 0 (OS çalışıyor)

    # --- İlk İpliği (Thread 1) Çalıştır ---
    # 1. Thread 1'in durumunu RUNNING yap (Bu aslında zamanlayıcının işi olmalı, şimdilik atlıyoruz)
    # SET 1, 27      # TCB1_STATE = Running (memory[27]=1)

    # 2. Thread 1'in PC'sini (memory[28]'den) geçici bir adrese (70) kopyala.
201: CPY 28, 70     # memory[70] = TCB1_PC (yani 1000)
    # 3. Thread 1'in SP'sini (memory[29]'dan) alıp CPU'nun SP'sine (memory[1]) yaz.
202: CPY 29, 1      # CPU_SP = TCB1_SP (1990)

    # 4. Thread 1'in ID'sini current_running_thread_id yap (memory[15]).
203: CPY 26, 15     # current_running_thread_id = TCB1_ID (yani 1)

    # 5. USER moduna geç ve Thread 1'i başlat.
    # USER A komutu PC = memory[A] yapar. memory[70]'de Thread 1'in PC'si (1000) var.
204: USER 70        # PC = memory[70] (yani 1000), Mode = USER
    
    # Kontrol Thread 1'e geçer.

    # --- OS Ana Bekleme/Zamanlama Döngüsü (Çok Basit Yer Tutucu) ---
210: HLT            # Normalde buraya gelinmez, syscall handler'lar zamanlayıcıya döner.

    # --- Sistem Çağrısı İşleyicileri ---
    # SYSCALL_HLT Handler (Başlangıç Adresi: memory[11] = 300)
300: SET 0, 15      # current_running_thread_id = 0 (Kontrol OS'ye geçti)
    # Yapılacaklar:
    # - SYSCALL yapan ipliğin (memory[15]'e göre değil, önceki değere göre) STATE'ini Halted yap.
    # - Zamanlayıcıyı çağır (başka bir iplik seç).
    # - Eğer çalışacak başka iplik yoksa OS_HLT (210) adresine git.
    # Şimdilik direkt OS'yi HLT et:
301: SET 210, 0     # PC = OS_HLT_Address (210). Bu, CPU'nun PC'sine (memory[0]) 210 yazar.
                    # cpu.py'daki SET X,0 düzeltmesi sayesinde PC sonda tekrar artmaz.
302: HLT            # BU KOMUT ÇALIŞMAZ, çünkü PC 301'den sonra 210 olur.


    # SYSCALL_YIELD Handler (Başlangıç Adresi: memory[12] = 400)
400: SET 0, 15      # current_running_thread_id = 0 (Kontrol OS'ye geçti)
    # Yapılacaklar:
    # - Mevcut ipliğin PC ve SP'sini TCB'sine kaydet. State'ini Ready yap.
    # - Zamanlayıcıyı çağır. Yeni ipliği yükle ve USER ile başlat.
    # Şimdilik direkt OS'yi HLT et:
401: SET 210, 0     # PC = OS_HLT_Address (210)
402: HLT            # BU KOMUT ÇALIŞMAZ.

    #-----------------------------------------------------
    # THREAD 1 KOMUTLARI
    #-----------------------------------------------------
    # Başlangıç adresi TCB1_PC (memory[28]) = 1000
1000: SET 1, 1200      # Thread 1'in çalıştığını göstermek için basit bir işlem (Mem[1200]=1)
1001: SYSCALL_PRN 1050 # memory[1050]'deki değeri (789) yazdır
1002: SYSCALL_HLT      # İpliği sonlandır (kontrol OS'deki HLT handler'a (300) geçer)

End Instruction Section # TÜM KOMUT BÖLÜMLERİ BİTTİ