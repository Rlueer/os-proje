# os_plus_threads.gtu
# OS ve Iki Basit Iplik (Thread 1 & Thread 2)
# Adres cakismalari ve scheduler mantigi duzeltilmis hali
# Corrections: Line 654 (SET 1, 15), Line 655 (SYSCALL_PRN 15), Line 706 (JIF 0, 203)

#-----------------------------------------------------
# VERI BOLUMU
#-----------------------------------------------------
Begin Data Section
    # --- CPU Ozel Yazmaclari ---
    0 = 200         # OS PC Baslangici
    1 = 990         # OS SP Baslangici
    # memory[2] (SysCall Result) CPU tarafindan YIELD sonrasi donus PC'sini tutacak
    # memory[3] (Instr Executed) CPU tarafindan kullanilir

    # --- OS Ozel Alanlari ---
    10 = 0          # Son Syscall Turu (0:PRN, 1:HLT, 2:YIELD) - CPU ayarlar
    11 = 300        # SYSCALL_HLT Handler Adresi
    12 = 400        # SYSCALL_YIELD Handler Adresi
    15 = 0          # current_running_thread_id (0:OS, 1:T1, 2:T2) - OS gunceller
    16 = 1          # next_thread_to_run_id (Scheduler bunu gunceller)
    17 = 0          # Gecici - YIELD yapan ipligin TCB'sine kaydedilecek PC'yi tutar
    18 = 0          # Gecici - YIELD yapan ipligin TCB'sine kaydedilecek SP'yi tutar

    # --- Iplik Tablosu (TCB) ---
    # Her iplik: ID(offset 0), State(offset 1: 0=Ready,1=Run,2=Block,3=Halt), SavedPC(offset 2), SavedSP(offset 3)
    # TCB_SIZE = 4 (ID, State, PC, SP icin simdilik) StackBase/Limit daha sonra eklenebilir.
    # OS (Thread 0) - ID=0
    20 = 0          # TCB0_ID
    21 = 1          # TCB0_STATE (Running)
    22 = 200        # TCB0_PC
    23 = 990        # TCB0_SP

    # Thread 1 (ID=1)
    24 = 1          # TCB1_ID
    25 = 0          # TCB1_STATE (Ready)
    26 = 1000       # TCB1_PC (Baslangic adresi)
    27 = 1990       # TCB1_SP (Baslangic SP'si)

    # Thread 2 (ID=2)
    28 = 2          # TCB2_ID
    29 = 0          # TCB2_STATE (Ready)
    30 = 2000       # TCB2_PC (Baslangic adresi)
    31 = 2990       # TCB2_SP (Baslangic SP'si)

    # --- Gecici Hesaplama/Saklama Alanlari (OS Kullanimi Icin) ---
    70 = 0          # USER komutu icin yeni PC'yi (iplik PC'si) tutar
    71 = 0          # Karsilastirma / TCB adresi icin gecici deger
    72 = 0          # Karsilastirma / iplik ID'si / state icin gecici deger
    73 = 1          # Sabit 1
    74 = 2          # Sabit 2
    75 = 3          # Sabit 3 (Halted state)
    76 = 4          # TCB_SIZE (ID, State, PC, SP)
    77 = 20         # TCB_START_ADDRESS (ilk TCB'nin baslangic adresi - OS TCB'si)
    # TCB Offsetleri: ID_OFFSET=0, STATE_OFFSET=1, PC_OFFSET=2, SP_OFFSET=3

    78 = 0          # CHECK_THREADS icin t1_state gecici alani
    79 = 0          # CHECK_THREADS icin t2_state gecici alani
    80 = 0          # TCB1_STATE_ADDR (Hesaplanacak: 20 + 1*4 + 1 = 25)
    81 = 0          # TCB1_PC_ADDR (Hesaplanacak: 20 + 1*4 + 2 = 26)
    82 = 0          # TCB1_SP_ADDR (Hesaplanacak: 20 + 1*4 + 3 = 27)
    83 = 0          # TCB2_STATE_ADDR (Hesaplanacak: 20 + 2*4 + 1 = 29)
    84 = 0          # TCB2_PC_ADDR (Hesaplanacak: 20 + 2*4 + 2 = 30)
    85 = 0          # TCB2_SP_ADDR (Hesaplanacak: 20 + 2*4 + 3 = 31)

    # --- THREAD 1 Veri Alani (1000-1999) ---
    1050 = 111      # Thread 1'in yazdiracagi ilk deger
    1051 = 112      # Thread 1'in yazdiracagi ikinci deger
    1200 = 0
    1201 = 0

    # --- THREAD 2 Veri Alani (2000-2999) ---
    2050 = 221
    2051 = 222
    2200 = 0
    2201 = 0

End Data Section

Begin Instruction Section
    #-----------------------------------------------------
    # ISLETIM SISTEMI KOMUTLARI (Baslangic PC=200)
    #-----------------------------------------------------
    # --- OS Baslangic ---
200: SET 0, 15      # current_running_thread_id = 0 (OS)
201: SET 1, 16      # next_thread_to_run_id = 1
202: CALL 600       # GOTO_SCHEDULER_AND_RUN_THREAD
203: HLT            # OS Final HLT

# --- Sistem Cagrisi Isleyicileri ---
    # SYSCALL_HLT Handler (memory[11]=300)
    # HLT yapan ipligin ID'si SYSCALL aninda memory[15]'te (current_running_thread_id) idi.
300: CPY 15, 72     # halted_thread_id = memory[15] (SYSCALL yapan ipligin ID'si)
301: SET 0, 15      # current_running_thread_id = 0 (OS kontrolu aldi)

    # Halted thread'in STATE'ini 'Halted' (3) yap.
    # temp_id (memory[70]) = halted_thread_id - 1 hesapla
302: CPY 72, 70     # temp_id (memory[70]) = halted_thread_id (memory[72])
303: ADD 70, -1     # temp_id (memory[70]) = temp_id - 1

    # if (temp_id <= 0) yani (halted_thread_id == 1) ise 310'a git
304: JIF 70, 310

    # ELSE (halted_thread_id == 2)
305: SET 3, 29      # TCB2_STATE (memory[29]) = Halted (3)
306: JIF 0, 312     # Her zaman Scheduler'a git (312)

    # IF (halted_thread_id == 1)
310: SET 3, 25      # TCB1_STATE (memory[25]) = Halted (3)
    # Her iki durumda da Scheduler'i cagir
312: CALL 600       # Bir sonraki ipligi calistir veya OS'yi HLT et (scheduler karar verir)
313: HLT            # Guvenlik HLT'si

# SYSCALL_YIELD Handler (memory[12]=400)
399: SYSCALL_PRN 15   # Handler'a girmeden once "memory[15]" ne?
400: CPY 15, 72     # yielded_thread_id = memory[15]
401: SET 0, 15      # current_running_thread_id = 0 (OS kontrolu aldi)
402: CPY 2, 17      # saved_pc = memory[2] 
403: CPY 1, 18      # saved_sp = memory[1]

# EXTRA DEBUG
404: SYSCALL_PRN 72   # yielded_thread_id yazdir
405: SYSCALL_PRN 17   # saved_pc yazdir
406: SYSCALL_PRN 15   # current_running_thread_id yazdir (0 olmali)

# Thread kontrolu
407: CPY 72, 70     # temp_id = yielded_thread_id
408: ADD 70, -1     # temp_id = temp_id - 1 
409: SYSCALL_PRN 70   # temp_id yazdir (debug)
410: JIF 70, 425    # IF temp_id <= 0 (yani yielded_id == 1 or 0 or less) GOTO TCB1_Save_Context

    # ELSE (yielded_id > 0, presumably 2 if not 1) - Thread 2'nin context'ini kaydet
411: SYSCALL_PRN 30   # TCB2_PC eski degeri yazdir
412: CPY 17, 30     # TCB2_PC = saved_pc
413: SYSCALL_PRN 30   # TCB2_PC yeni degeri yazdir
414: CPY 18, 31     # TCB2_SP = saved_sp
415: SET 0, 29      # TCB2_STATE = Ready (0)
416: SET 1, 16      # next_thread_to_run_id = 1
417: JIF 0, 430     # GOTO Scheduler

    # TCB1_Save_Context (yielded_id was 1, or erroneously 0 or less)
425: CPY 17, 26     # TCB1_PC = saved_pc
426: CPY 18, 27     # TCB1_SP = saved_sp
427: SET 0, 25      # TCB1_STATE = Ready (0)
428: SET 2, 16      # next_thread_to_run_id = 2
429: JIF 0, 430     # GOTO Scheduler

    # Scheduler'i cagir
430: CALL 600       # GOTO_SCHEDULER_AND_RUN_THREAD
431: HLT            # Guvenlik HLT'si

# --- Alt Program: SCHEDULER_AND_RUN_THREAD (Adres 600) ---
600: CALL 700       # CHECK_IF_ALL_THREADS_HALTED
601: CPY 16, 71     # run_id_candidate = memory[16] -> memory[71] (bos gecici alan)

    # if run_id_candidate == 1     ## enesin bahsettigi çıkarma problemi ###############
602: CPY 71, 72     # run_id_candidate -> memory[72]
603: ADD 72, -1     # memory[72] = run_id_candidate - 1
604: JIF 72, 640    # Eger (run_id_candidate - 1) <= 0 (yani ID=1) ise 640'a git (T1 kontrol/yukle)

    # ELSE (run_id_candidate == 2) -> Thread 2'yi kontrol et/yukle
605: CPY 29, 72     # TCB2_STATE (memory[29]) -> memory[72]
606: JIF 72, 615    # Eger TCB2_STATE <= 0 (READY) ise 615'e git (T2 Yukle)
    # T2 Ready degilse (Blocked veya Halted ise), T1'i dene (next_id=1 yap)
607: SET 1, 16      # next_thread_to_run_id = 1
608: JIF 0, 600     # Scheduler'i en bastan tekrar cagir

    # Thread 2'yi Yukle ve Calistir (Adres 615)
615: CPY 30, 0      # CPU_PC = TCB2_PC
616: CPY 31, 1      # CPU_SP = TCB2_SP
617: SET 2, 15      # current_running_thread_id = 2
618: SYSCALL_PRN 15 # DEBUG: memory[15] degerini kontrol et (2 olmali)
619: SET 1, 29      # TCB2_STATE (memory[29]) = Running (1)
620: CPY 0, 70      # memory[70] = CPU_PC (Thread 2'nin PC'si)
621: USER 70        # Thread 2'yi baslat
622: HLT            # Guvenlik HLT'si

    # Thread 1'i kontrol et/yukle (Adres 640)
640: CPY 25, 72     # TCB1_STATE (memory[25]) -> memory[72]
641: JIF 72, 650    # Eger TCB1_STATE <= 0 (READY) ise 650'ye git (T1 Yukle)
    # T1 Ready degilse, T2'yi dene (next_id=2 yap)
642: SET 2, 16      # next_thread_to_run_id = 2
643: JIF 0, 600     # Scheduler'i en bastan tekrar cagir

# Thread 1'i Yukle ve Calistir (Adres 650)
650: CPY 26, 0      # CPU_PC = TCB1_PC (1000)
651: SYSCALL_PRN 999 # DEBUG: 651 oncesi - buraya geldigi kaniti
652: CPY 27, 1      # CPU_SP = TCB1_SP (1990)
653: SYSCALL_PRN 888 # DEBUG: 652 sonrasi - buraya geldi mi?
654: SET 1, 15      # current_running_thread_id = 1 (CORRECTED from 19 to 15)
655: SYSCALL_PRN 15 # DEBUG: memory[15] degerini kontrol et (CORRECTED from 19 to 15)
656: SET 1, 25      # TCB1_STATE = Running
657: CPY 0, 70      # memory[70] = CPU_PC
658: USER 70        # Thread 1'i baslat
659: HLT            # Guvenlik HLT'si

# --- Alt Program: CHECK_IF_ALL_THREADS_HALTED (Adres 700) ---
700: CPY 25, 78     # t1_state = TCB1_STATE -> memory[78] (cakisma olmasin)
701: CPY 29, 79     # t2_state = TCB2_STATE -> memory[79] (cakisma olmasin)
702: ADD 78, -3     # t1_state_check = t1_state - 3
703: JIF 78, 710    # If t1_state <= 3, JUMP to RET (Still potentially flawed logic, but not the primary bug)
704: ADD 79, -3     # t2_state_check = t2_state - 3 
705: JIF 79, 710    # If t2_state <= 3, JUMP to RET (Still potentially flawed logic)
706: JIF 0, 203     # Ikisi de Halted (according to flawed JIFs), OS'yi HLT et (CORRECTED target to 203)
710: RET            # En az biri Ready/Running (or JIF logic error made it come here), scheduler devam etsin

    #-----------------------------------------------------
    # THREAD 1 KOMUTLARI (Baslangic: 1000)
    #-----------------------------------------------------
1000: SYSCALL_PRN 15 # DEBUG: Thread 1 baslarken current_thread_id (1 olmali)
1001: SET 111, 1050
1002: SYSCALL_PRN 1050
1003: SYSCALL_YIELD
1004: SYSCALL_PRN 15 # DEBUG: YIELD sonrasi geri dondugunde (1 olmali)
1005: SET 112, 1051
1006: SYSCALL_PRN 1051
1007: SYSCALL_HLT

    #-----------------------------------------------------
    # THREAD 2 KOMUTLARI (Baslangic: 2000)
    #-----------------------------------------------------
2000: SYSCALL_PRN 15 # DEBUG: Thread 2 baslarken current_thread_id (2 olmali)
2001: SET 221, 2050
2002: SYSCALL_PRN 2050
2003: SYSCALL_YIELD
2004: SYSCALL_PRN 15 # DEBUG: YIELD sonrasi geri dondugunde (2 olmali)
2005: SET 222, 2051
2006: SYSCALL_PRN 2051
2007: SYSCALL_HLT

End Instruction Section